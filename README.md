# Software-Engineering-Lab-AZ3

<br>

 ## آزمایش ابتدایی برای گرفتن پوشش آزمون 
 همانطور که خواسته شده بود test coverage را برای پروژه json-simle اجرا کردیم. به این ترتیب که بر روی کلاس تست، کلیک راست کرده و گزینه Run TestJson with Coverage را انتخاب کردیم که در زیر میتوانید تصاویر خروجی را ببینید:
<br>

![Screenshot (120)](https://github.com/user-attachments/assets/454cfab3-68a2-4cb9-b1be-31fb97eff2a8)

![image](https://github.com/user-attachments/assets/fdc4de8b-552d-42b8-b676-cdf0b46dbb05)



 ![Screenshot (121)11](https://github.com/user-attachments/assets/d1e71d22-9e64-4374-8559-7c697810ff41)


مشکل اولی که پیدا کردیم این هست که در متد lendBook در کلاس Library، بررسی نمی‌شود که آیا دانش‌آموزی که درخواست امانت کتاب را داده است، عضو کتابخانه هست یا خیر. این مسئله می‌تواند منجر به این شود که کتابی به دانش‌آموزی که عضو کتابخانه نیست امانت داده شود، که واضحا عملکرد اشتباهی است. <br>
برای اطمینان از وجود این مشکل، یک تست نوشتیم. در این تست، سعی کردیم کتابی را به دانش‌آموزی که عضو کتابخانه نیست امانت دهیم. در این حالت، انتظار داریم که عملیات قرض دادن ناموفق باشد و کتاب همچنان در مجموعه کتابخانه باقی بماند. <br>
در زیر می‌توانید عکس مربوط به نتیجه‌ی فیل شدن تست را مشاهده کنید: <br> <br>

![image](https://github.com/user-attachments/assets/1c007a1c-3236-46bb-9f72-43e7b031abe5)
<br>
<br>
حال به عنوان شرط اول این موضوع را در تابع مربوطه چک میکنیم. در عکس زیر کد مربوط به آن را مشاهده میکنید: <br> <br>

![image](https://github.com/user-attachments/assets/0c2a8261-cf97-4d71-a2f5-6e4c4920e85c)
<br>
<br>
حال مجددا تست را ران میکنیم و مطابق عکس زیر مشاهده میکنیم که پاس می‌شود: <br> <br>

![image](https://github.com/user-attachments/assets/98bf4d29-0dd3-4b70-b855-2081acf6701a)
<br>
<br>
<br>
مشکل دوم مربوط به متد returnBook در کلاس Library بود. این متد باید اطمینان حاصل کند که وقتی یک کتاب توسط یک دانش‌آموز بازگردانده می‌شود، آن کتاب از لیست کتاب‌های دانش‌آموز حذف شود و همچنین باید بررسی کند که در ورودی کتاب و دانش‌آموز نال نباشند. <br>
برای اطمینان از وجود این مشکل، دو تست نوشتیم. در این تست‌ها، سعی کردیم مطمئن شویم که کتاب به درستی به کتابخانه بازگردانده می‌شود و از لیست کتاب‌های دانش‌آموز حذف می‌شود، همچنین بررسی کردیم که کتاب و دانش‌آموز نال نباشند. <br>
در زیر می‌توانید عکس مربوط به نتیجه‌ی فیل شدن تست‌ها را مشاهده کنید: <br> <br>
![image](https://github.com/user-attachments/assets/98038139-8bdc-457e-8126-a8fa037893b2)
<br>
<br>
حال تابع را اصلاح میکنیم که عکس آن را در زیر مشاهده میکنید: <br> <br>
![image](https://github.com/user-attachments/assets/4f43618b-ced1-4144-8714-626500b65260)
<br>
<br>
حال مجددا تست‌ها را ران میکنیم و مطابق عکس زیر مشاهده میکنیم که پاس می‌شوند: <br> <br>
![image](https://github.com/user-attachments/assets/4891be58-623f-4b37-bc0b-029d5af6ffea)
<br>
<br>
<br>

تست‌های نوشته شده برای متد searchStudents در کلاس Library هدفشان پوشش دادن تمام جنبه‌های عملکرد متد تعریف شده در کامنت‌ها هست. این تست‌ها به دو دسته اصلی تقسیم می‌شوند: <br>
در دسته اول، تست‌هایی مانند testSearchStudentsById و testSearchStudentsByName مستقیماً خواسته‌های متد را که شامل شناسایی دانش‌آموزان بر اساس ID یا نام است، بررسی می‌کنند. این تست‌ها اطمینان می‌دهند که متد توانایی یافتن دانش‌آموزان مطابق با کلیدهای داده شده را دارد و لیست صحیحی از نتایج را بازمی‌گرداند. <br>
در دسته دوم، تست‌هایی مانند testSearchStudentsByNonExistentId و testSearchStudentsByNonExistentName وضعیت‌هایی را بررسی می‌کنند که در آنها جستجو برای IDها یا نام‌هایی که وجود ندارند انجام می‌شود. این تست‌ها مطمئن می‌شوند که متد در صورت عدم یافتن هیچ نتیجه‌ای، لیست خالی بازمی‌گرداند، که نشان‌دهنده رفتار مناسب متد در مواجهه با ورودی‌های نامعتبر است. <br>
علاوه بر این، تست‌هایی مانند testSearchStudentsByInvalidTypeTitle و testSearchStudentsByInvalidTypeAuthor بررسی می‌کنند که متد چگونه با تایپ‌های جستجویی که برای دانش‌آموزان پشتیبانی نمی‌شوند، رفتار می‌کند. این تست‌ها انتظار دارند که متد در این موارد null بازگرداند، تا نشان دهند که تایپ‌های جستجوی غیرمعتبر به درستی مدیریت می‌شوند. <br>
حال در زیر تصویری از ران شدن این 6 تست را میبینید: <br> <br>
![image](https://github.com/user-attachments/assets/54cff7a4-eb1c-498a-8ae6-762475a55861)
دلیل اینکه دو تست پاس شده‌اند این است که این تست‌ها انتظار برگرداندن null را داشته‌اند که در تعریف اولیه تابع که به ما داده شده است خروجی null بازگردانده می‌شود. <br> <br>
حال بعد از کامل کردن کد تابع مجددا تست‌ها را ران می‌کنیم که خروجی آن‌ها را در تصویر زیر می‌توانید مشاهده کنید: <br> <br>
![image](https://github.com/user-attachments/assets/290186cc-db6a-499c-b8a0-3f240a4b18b5)
<br>
<br>
<br>
در کلاس تست BookTest هشت تست مختلف طراحی شده‌اند تا کارکرد تابع searchBooks را در شرایط گوناگون مورد بررسی قرار دهند. این تست‌ها هم عملکرد درست تابع در بازگرداندن کتاب‌ها براساس پارامترهای متفاوت را مورد سنجش قرار می‌دهند و هم واکنش آن به ورودی‌های نامعتبر یا غیرموجود را ارزیابی می‌کنند. <br>
تست‌های testSearchBooksById, testSearchBooksByTitle, و testSearchBooksByAuthor تأکید می‌کنند که تابع باید قادر به شناسایی کتاب‌ها بر اساس شناسه، عنوان، و نویسنده باشد. <br>
برای تست وجود نداشتن کتاب‌ها، مانند testSearchBooksByNonExistentId و testSearchBooksByNonExistentTitle, این آزمون‌ها تضمین می‌کنند که تابع در صورت جستجو برای شناسه‌ها یا عناوینی که در کتابخانه وجود ندارند، یک لیست خالی بازمی‌گرداند. <br>
علاوه بر این، testSearchBooksByInvalidType بررسی می‌کند که تابع باید در پاسخ به تایپ جستجویی که معتبر نیست، مانند NAME که برای کتاب‌ها تعریف نشده، null بازگرداند. این نشان‌دهنده رعایت قراردادهای تعیین شده در توضیحات تابع است. <br>
نهایتاً، تست‌های testSearchBooksByTitleWithMultipleResults و testSearchBooksByAuthorWithMultipleResults نشان می‌دهند که تابع چگونه با شرایطی که بیش از یک نتیجه معتبر وجود دارد برخورد می‌کند. این تست‌ها اطمینان می‌دهند که تابع قادر است تمام کتاب‌هایی که با کلیدهای جستجو مطابقت دارند را بازگرداند و به این ترتیب قابلیت اطمینان تابع در شرایطی که چندین موردی بازگردانی شود، سنجیده می‌شود. <br>
خال در زیر تصویری از ران شدن این 8 تست را میبینید: <br> <br>
![image](https://github.com/user-attachments/assets/fad6d5f3-232a-4236-bc3c-3b088e985b01)

دلیل اینکه یک تست پاس شده‌ این است که این تست‌ انتظار برگرداندن null را داشته‌ که در تعریف اولیه تابع که به ما داده شده است خروجی null بازگردانده می‌شود. <br> <br>
حال بعد از کامل کردن کد تابع مجددا تست‌ها را ران می‌کنیم که خروجی آن‌ها را در تصویر زیر می‌توانید مشاهده کنید: <br> <br>
![image](https://github.com/user-attachments/assets/6aa1dd31-4396-4a5c-8b33-e5ad18e7ca0f)
<br>
<br>
<br>
در نهایت برای به پایان رساندن این بخش بر روی پوشه test.classes کلیک راست میکنیم و از بین گزینه‌ها گزینه‌ی  Run Tests in test.classes with Coverage را انتخاب کردیم که پوشش کد را مشخص کند. تصویر زیر نتیجه را نشان می‌دهد: (عملا پاسخ به سوال سوم در بخش سوم است.) <br> <br>
![image](https://github.com/user-attachments/assets/0437ad2e-e33c-4d38-b53d-513d2cb89fbe)
<br>
<br>
<br>

# پرسش ها
<br>


 ## سوال 1


**روش TDD (توسعه مبتنی بر تست)** برای پروژه‌های بزرگ و پیچیده مناسب‌تر است. این روش به بهبود کیفیت کد و درک بهتر نیازمندی‌ها کمک می‌کند و کد را به واحدهای کوچک‌تر و قابل تست تقسیم می‌کند. اما به مهارت و تجربه بیشتری نیاز دارد و در پروژه‌هایی که نیازمندی‌ها ناپایدار هستند، کاربرد کمتری دارد. همچنین، اگرچه در کوتاه‌مدت زمان بیشتری می‌برد، اما در بلندمدت با کاهش خطاها و بهبود کیفیت، زمان توسعه را کاهش می‌دهد.

**روش تست سنتی** مناسب پروژه‌های کوچک‌تر و کم‌پیچیدگی است، زیرا نوشتن تست‌ها بعد از کد، زمان و تلاش کمتری می‌طلبد. این روش برای پروژه‌هایی که نیازمندی‌های ناپایداری دارند یا تیم توسعه‌دهنده تجربه کافی در TDD ندارد، مناسب‌تر است. همچنین، تست سنتی برای پروژه‌هایی که به راه‌اندازی سریع نیاز دارند، انتخاب بهتری است.
<br>
## سوال 2
در فرآیند ایجاد نرم‌افزار، تیم ایجاد (Development Team) و تیم تضمین کیفیت (QA Team) هر کدام بیشتر با دسته‌های خاصی از انواع تست سروکار دارند:

### تیم ایجاد (Development Team)
تیم ایجاد عمدتاً از **تست جعبه سفید (White-Box Testing)** استفاده می‌کند، زیرا این تیم دسترسی به کد منبع دارد و بر اساس ساختار داخلی نرم‌افزار تست‌ها را طراحی می‌کند.

- **تست واحد (Unit Testing):** بررسی واحدهای کوچک و مجزای نرم‌افزار مانند توابع یا متدها، برای اطمینان از عملکرد صحیح آن‌ها.
- **تست یکپارچه‌سازی (Integration Testing):** اطمینان از اینکه واحدهای مختلف نرم‌افزار پس از ترکیب، به درستی با هم کار می‌کنند.
- **تست استاتیک (Static Testing):** تحلیل کد منبع و مستندات بدون اجرای نرم‌افزار، برای شناسایی خطاها و انحرافات از استانداردها.

### تیم تضمین کیفیت (QA Team)
تیم تضمین کیفیت بیشتر از **تست جعبه سیاه (Black-Box Testing)** استفاده می‌کند، زیرا این تیم نیازی به دسترسی به ساختار داخلی نرم‌افزار ندارد و تمرکز بر روی عملکرد و ویژگی‌های بیرونی نرم‌افزار دارد.

- **تست عملکردی (Functional Testing):** بررسی عملکرد نرم‌افزار بر اساس نیازمندی‌های مشخص شده، برای اطمینان از اینکه همه ویژگی‌ها به درستی کار می‌کنند.
- **تست رابط کاربری (UI Testing):** بررسی عناصر و تعاملات رابط کاربری نرم‌افزار، برای اطمینان از استفاده‌پذیری و کارکرد صحیح اجزای بصری.
- **تست استفاده‌پذیری (Usability Testing):** ارزیابی راحتی استفاده، کاربرپسندی و میزان رضایت کاربران از نرم‌افزار.
- **تست سازگاری (Compatibility Testing):** اطمینان از سازگاری نرم‌افزار با سیستم‌عامل‌ها، مرورگرها و محیط‌های مختلف. 

این تقسیم‌بندی وظایف به تیم‌ها اجازه می‌دهد تا با تمرکز بر جنبه‌های مختلف نرم‌افزار، کیفیت کلی محصول را افزایش دهند.

